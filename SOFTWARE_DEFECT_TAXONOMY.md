# Software Defect Taxonomy for Python Web Applications

A comprehensive, machine-readable catalog of common software defects found in Python-based web applications, specifically targeting FastAPI frameworks. This taxonomy serves as ground truth for benchmarking AI code review agents.

This taxonomy contains **9 categories** with **7 defects each** (63 total defects) covering the full spectrum of issues commonly found in Python web applications.

## Correctness & Logic Errors

| Issue ID | Issue Name | Description | Difficulty | Flawed Python Snippet | Suggested Fix Description |
| :--- | :--- | :--- | :--- | :--- | :--- |
| `LOG-001` | Off-by-One Error | This occurs when a loop iterates one time too many or too few. It's a common mistake with loop conditions, often leading to `IndexError` exceptions or silently missed data processing. | Easy | ```python<br>items = [10, 20, 30]<br>for i in range(len(items) + 1):<br>    if i < len(items):<br>        print(items[i])<br>``` | The loop condition `range(len(items) + 1)` should be changed to `range(len(items))` to prevent iterating beyond the list's bounds. |
| `LOG-002` | Incorrect Boolean Logic | Occurs when logical operators (and/or) are misused or when boolean conditions are negated incorrectly. This can lead to incorrect conditional execution and unexpected behavior in API endpoints. | Medium | ```python<br>@app.post("/users/")<br>def create_user(user: User):<br>    if not user.email or not user.password:<br>        # Should be 'and' not 'or'<br>        raise HTTPException(400, "Missing credentials")<br>    return create_user_account(user)<br>``` | Change the condition to `if not user.email and not user.password:` or better yet, `if not (user.email and user.password):` to correctly validate that both fields are present. |
| `LOG-003` | Unhandled None Values | Failure to check for None values before accessing attributes or methods, leading to `AttributeError` exceptions. Common in API responses and database query results. | Easy | ```python<br>def get_user_profile(user_id: int):<br>    user = database.get_user(user_id)<br>    return {<br>        "name": user.name,<br>        "email": user.email.lower()<br>    }<br>``` | Add a null check: `if user is None: raise HTTPException(404, "User not found")` before accessing user attributes to handle cases where the database query returns None. |
| `LOG-004` | Incorrect Exception Handling | Catching overly broad exceptions or failing to handle specific exception types appropriately. This can mask important errors and make debugging difficult. | Medium | ```python<br>@app.get("/data/{file_id}")<br>def get_data(file_id: str):<br>    try:<br>        with open(f"data/{file_id}.json") as f:<br>            return json.load(f)<br>    except Exception:<br>        return {"error": "File not found"}<br>``` | Replace the broad `except Exception:` with specific exceptions like `except (FileNotFoundError, JSONDecodeError):` and handle each appropriately with different HTTP status codes. |
| `LOG-005` | Mutable Default Arguments | Using mutable objects (lists, dictionaries) as default function arguments, causing shared state between function calls. This leads to unexpected behavior where modifications persist across calls. | Hard | ```python<br>def add_tag(post_id: int, tag: str, tags=[]):<br>    tags.append(tag)<br>    return update_post_tags(post_id, tags)<br>``` | Change the default argument to `tags=None` and initialize inside the function: `if tags is None: tags = []` to ensure each function call gets a fresh list. |
| `LOG-006` | Integer Division Error | Using floor division (`//`) when true division (`/`) is needed, or vice versa. This is particularly problematic in calculations involving rates, percentages, or pagination logic. | Medium | ```python<br>@app.get("/posts/")<br>def get_posts(page: int = 1, per_page: int = 10):<br>    total_posts = get_total_post_count()<br>    total_pages = total_posts // per_page<br>    return {"posts": get_posts_slice(page), "total_pages": total_pages}<br>``` | Use proper ceiling division: `import math; total_pages = math.ceil(total_posts / per_page)` to ensure the last page is included even when it's not completely full. |
| `LOG-007` | Incorrect String Comparison | Performing case-sensitive string comparisons when case-insensitive comparison is needed, or failing to normalize strings before comparison. Common in email validation and search functionality. | Easy | ```python<br>def authenticate_user(email: str, password: str):<br>    user = get_user_by_email(email)<br>    if user and user.email == email:<br>        return verify_password(user, password)<br>    return False<br>``` | Normalize the email comparison: `if user and user.email.lower() == email.lower():` to handle cases where the stored email and provided email have different capitalizations. |

## Security Vulnerabilities

| Issue ID | Issue Name | Description | Difficulty | Flawed Python Snippet | Suggested Fix Description |
| :--- | :--- | :--- | :--- | :--- | :--- |
| `SEC-001` | SQL Injection Vulnerability | Occurs when user input is directly concatenated into SQL queries without proper sanitization. This allows attackers to manipulate database queries and potentially access or modify unauthorized data. | Hard | ```python<br>@app.get("/users/search")<br>def search_users(name: str):<br>    query = f"SELECT * FROM users WHERE name = '{name}'"<br>    return database.execute(query)<br>``` | Use parameterized queries or an ORM: `query = "SELECT * FROM users WHERE name = %s"; database.execute(query, (name,))` to prevent SQL injection attacks. |
| `SEC-002` | Hardcoded Credentials | Sensitive information like API keys, passwords, or tokens are hardcoded in the source code. This exposes credentials to anyone with access to the codebase and makes credential rotation difficult. | Easy | ```python<br>DATABASE_URL = "postgresql://admin:secret123@localhost/mydb"<br>API_SECRET_KEY = "super-secret-key-12345"<br><br>app = FastAPI()<br>``` | Move credentials to environment variables: `DATABASE_URL = os.getenv("DATABASE_URL")` and `API_SECRET_KEY = os.getenv("API_SECRET_KEY")` and store them in a `.env` file or deployment configuration. |
| `SEC-003` | Missing Input Validation | Failing to validate user input for type, length, format, or malicious content. This can lead to various attacks including XSS, injection attacks, and system crashes. | Medium | ```python<br>@app.post("/upload")<br>def upload_file(filename: str, content: str):<br>    with open(f"uploads/{filename}", "w") as f:<br>        f.write(content)<br>    return {"status": "uploaded"}<br>``` | Add input validation: check filename for path traversal (`../`), validate file extensions, limit content size, and sanitize the filename using `os.path.basename()` and allowlist validation. |
| `SEC-004` | Insecure Random Number Generation | Using predictable random number generators for security-sensitive operations like token generation, session IDs, or cryptographic nonces. This makes the system vulnerable to prediction attacks. | Hard | ```python<br>import random<br><br>def generate_session_token():<br>    return ''.join(random.choices('abcdef0123456789', k=32))<br>``` | Use cryptographically secure random generation: `import secrets; return secrets.token_hex(16)` for generating unpredictable tokens suitable for security purposes. |
| `SEC-005` | Information Disclosure | Returning sensitive information in error messages, logs, or API responses that could help attackers understand the system structure or gain unauthorized access. | Medium | ```python<br>@app.post("/login")<br>def login(credentials: LoginRequest):<br>    try:<br>        user = authenticate(credentials.email, credentials.password)<br>        return {"token": create_token(user)}<br>    except DatabaseError as e:<br>        raise HTTPException(500, f"Database error: {str(e)}")<br>``` | Return generic error messages: `raise HTTPException(500, "Internal server error")` and log the detailed error internally without exposing it to the client. |
| `SEC-006` | Missing Authentication Check | API endpoints that should require authentication are accessible without proper authentication checks. This allows unauthorized access to protected resources. | Easy | ```python<br>@app.delete("/admin/users/{user_id}")<br>def delete_user(user_id: int):<br>    database.delete_user(user_id)<br>    return {"status": "deleted"}<br>``` | Add authentication dependency: `@app.delete("/admin/users/{user_id}") def delete_user(user_id: int, current_user: User = Depends(get_current_admin)):` to ensure only authenticated admin users can access this endpoint. |
| `SEC-007` | Insufficient Authorization | Users can access or modify resources they shouldn't have access to. The system checks if a user is authenticated but not if they have permission for the specific resource. | Hard | ```python<br>@app.get("/posts/{post_id}")<br>def get_post(post_id: int, user: User = Depends(get_current_user)):<br>    post = database.get_post(post_id)<br>    return post<br>``` | Add authorization check: `if post.is_private and post.author_id != user.id: raise HTTPException(403, "Access denied")` to ensure users can only access posts they own or public posts. |

## Performance Issues

| Issue ID | Issue Name | Description | Difficulty | Flawed Python Snippet | Suggested Fix Description |
| :--- | :--- | :--- | :--- | :--- | :--- |
| `PERF-001` | N+1 Query Problem | Making multiple database queries in a loop instead of using a single query with joins or bulk operations. This creates significant performance overhead as the dataset grows. | Hard | ```python<br>@app.get("/users/with-posts")<br>def get_users_with_posts():<br>    users = database.get_all_users()<br>    result = []<br>    for user in users:<br>        posts = database.get_posts_by_user(user.id)<br>        result.append({"user": user, "posts": posts})<br>    return result<br>``` | Use a single query with joins or eager loading: `users = database.get_users_with_posts()` or use an ORM feature like SQLAlchemy's `joinedload()` to fetch all related data in one query. |
| `PERF-002` | Missing Database Indexes | Querying database columns that are frequently used in WHERE clauses without proper indexes, leading to full table scans and poor performance. | Medium | ```python<br># Database schema missing index<br>@app.get("/posts/by-author")<br>def get_posts_by_author(author_email: str):<br>    # This query will scan the entire posts table<br>    return database.query("SELECT * FROM posts WHERE author_email = %s", author_email)<br>``` | Add a database index: `CREATE INDEX idx_posts_author_email ON posts(author_email);` to optimize queries that filter by author_email. Also consider composite indexes for multi-column queries. |
| `PERF-003` | Inefficient List Operations | Using inefficient operations like repeated list concatenation, searching unsorted lists, or checking membership in lists instead of using appropriate data structures. | Easy | ```python<br>@app.post("/tags/bulk-check")<br>def check_tags_exist(tag_names: List[str]):<br>    existing_tags = database.get_all_tag_names()  # Returns list<br>    result = []<br>    for tag in tag_names:<br>        if tag in existing_tags:  # O(n) lookup in list<br>            result.append(tag)<br>    return result<br>``` | Convert the list to a set for O(1) lookups: `existing_tags_set = set(database.get_all_tag_names())` and then use `if tag in existing_tags_set:` for much faster membership testing. |
| `PERF-004` | Unnecessary Object Creation | Creating objects or performing expensive operations inside loops or frequently called functions when they could be cached or computed once. | Medium | ```python<br>@app.get("/posts/{post_id}/formatted")<br>def get_formatted_post(post_id: int):<br>    post = database.get_post(post_id)<br>    formatter = PostFormatter()  # Created on every request<br>    formatter.configure(load_settings())  # Loads from disk<br>    return formatter.format(post)<br>``` | Cache expensive objects: use a module-level formatter `_formatter = PostFormatter()` and configure it once at startup, or use dependency injection with a singleton scope for the formatter. |
| `PERF-005` | Blocking I/O in Async Context | Using synchronous I/O operations in async functions, which blocks the event loop and prevents concurrent request handling. This negates the benefits of async programming. | Hard | ```python<br>@app.get("/external-data")<br>async def get_external_data():<br>    # Blocking synchronous HTTP call in async function<br>    response = requests.get("https://api.example.com/data")<br>    return response.json()<br>``` | Use async HTTP client: `import httpx; async with httpx.AsyncClient() as client: response = await client.get("https://api.example.com/data")` to maintain async behavior throughout the request pipeline. |
| `PERF-006` | Memory Leak in Generator Usage | Not properly closing generators or iterators, or keeping references to large objects longer than necessary, leading to memory accumulation over time. | Hard | ```python<br>@app.get("/large-dataset")<br>def process_large_dataset():<br>    data = database.get_all_records()  # Loads everything into memory<br>    processed = [expensive_transform(item) for item in data]<br>    return {"count": len(processed)}<br>``` | Use generators and streaming: `def process_records(): for record in database.stream_records(): yield expensive_transform(record)` and process items one at a time without loading everything into memory. |
| `PERF-007` | Inefficient JSON Serialization | Using default Python JSON serialization for complex objects or large datasets without considering performance implications. Can be particularly slow for datetime objects and nested structures. | Medium | ```python<br>@app.get("/reports/detailed")<br>def get_detailed_report():<br>    data = get_complex_report_data()  # Returns objects with datetimes<br>    return json.dumps(data, default=str)  # Slow default serialization<br>``` | Use faster JSON libraries: `import orjson; return orjson.dumps(data)` or optimize the default serializer by implementing custom serialization methods for datetime and other frequent types. |

## Concurrency & Asynchronous Code Issues

| Issue ID | Issue Name | Description | Difficulty | Flawed Python Snippet | Suggested Fix Description |
| :--- | :--- | :--- | :--- | :--- | :--- |
| `ASYNC-001` | Mixing Sync and Async Code | Calling synchronous functions within async functions without proper handling, which can block the event loop and degrade performance in concurrent scenarios. | Medium | ```python<br>@app.get("/user-data")<br>async def get_user_data(user_id: int):<br>    user = database.get_user_sync(user_id)  # Blocks event loop<br>    return {"user": user, "timestamp": time.time()}<br>``` | Use async database operations: `user = await database.get_user_async(user_id)` or if sync is necessary, use `user = await asyncio.to_thread(database.get_user_sync, user_id)` to run in a thread pool. |
| `ASYNC-002` | Race Condition in Shared State | Multiple async operations modifying shared state without proper synchronization, leading to inconsistent data and unpredictable behavior in concurrent environments. | Hard | ```python<br>counter = 0<br><br>@app.post("/increment")<br>async def increment():<br>    global counter<br>    current = counter<br>    await asyncio.sleep(0.1)  # Simulates async operation<br>    counter = current + 1<br>    return {"counter": counter}<br>``` | Use proper synchronization: `import asyncio; lock = asyncio.Lock()` then `async with lock: current = counter; await asyncio.sleep(0.1); counter = current + 1` to ensure atomic updates. |
| `ASYNC-003` | Forgotten Await Statement | Calling async functions without the await keyword, causing the function to return a coroutine object instead of the expected result. This is a common source of bugs in async code. | Easy | ```python<br>async def send_notification(user_id: int, message: str):<br>    return email_service.send_async(user_id, message)<br><br>@app.post("/notify")<br>async def notify_user(user_id: int, message: str):<br>    result = send_notification(user_id, message)  # Missing await<br>    return {"sent": bool(result)}<br>``` | Add the await keyword: `result = await send_notification(user_id, message)` to properly wait for the async operation to complete and get the actual result. |
| `ASYNC-004` | Improper Exception Handling in Async | Not properly handling exceptions in async operations, especially in fire-and-forget tasks or when using asyncio.gather(). Unhandled exceptions can crash the application. | Hard | ```python<br>@app.post("/batch-process")<br>async def batch_process(items: List[str]):<br>    tasks = [process_item_async(item) for item in items]<br>    await asyncio.gather(*tasks)  # Exceptions will propagate<br>    return {"status": "completed"}<br>``` | Handle exceptions properly: `await asyncio.gather(*tasks, return_exceptions=True)` and check results, or wrap each task: `tasks = [safe_process_item(item) for item in items]` where safe_process_item catches and logs exceptions. |
| `ASYNC-005` | Blocking Operations in Event Loop | Performing CPU-intensive or blocking operations directly in async functions, which prevents other async operations from running and degrades overall application performance. | Medium | ```python<br>@app.post("/calculate")<br>async def heavy_calculation(data: List[int]):<br>    # CPU-intensive operation blocking event loop<br>    result = sum(x ** 2 for x in data if x > 1000)<br>    return {"result": result}<br>``` | Use thread pool for CPU-bound work: `import asyncio; result = await asyncio.to_thread(lambda: sum(x ** 2 for x in data if x > 1000))` to prevent blocking the event loop. |
| `ASYNC-006` | Improper Task Creation | Creating tasks without proper lifecycle management, leading to memory leaks or zombie tasks that continue running after they're no longer needed. | Hard | ```python<br>@app.post("/start-background-job")<br>async def start_job(job_id: str):<br>    asyncio.create_task(long_running_job(job_id))  # Fire and forget, no cleanup<br>    return {"status": "started"}<br>``` | Manage task lifecycle: `task = asyncio.create_task(long_running_job(job_id)); background_tasks.add(task); task.add_done_callback(background_tasks.discard)` to track and clean up tasks properly. |
| `ASYNC-007` | Deadlock in Async Locks | Acquiring multiple locks in different orders or holding locks across await points can lead to deadlocks in async applications. This is particularly problematic in complex async workflows. | Hard | ```python<br>lock_a = asyncio.Lock()<br>lock_b = asyncio.Lock()<br><br>async def operation_1():<br>    async with lock_a:<br>        await asyncio.sleep(0.1)<br>        async with lock_b:  # Different order than operation_2<br>            return "done"<br><br>async def operation_2():<br>    async with lock_b:<br>        await asyncio.sleep(0.1)<br>        async with lock_a:  # Different order causes deadlock<br>            return "done"<br>``` | Ensure consistent lock ordering: always acquire locks in the same order across all functions, or use timeout-based lock acquisition: `async with asyncio.timeout(5.0): async with lock_a: async with lock_b:` to prevent indefinite blocking. |

## Code Architecture & Design Patterns

| Issue ID | Issue Name | Description | Difficulty | Flawed Python Snippet | Suggested Fix Description |
| :--- | :--- | :--- | :--- | :--- | :--- |
| `ARCH-001` | Violation of Single Responsibility | A class or function handles multiple unrelated responsibilities, making it difficult to maintain, test, and understand. This violates the Single Responsibility Principle from SOLID design principles. | Medium | ```python<br>class UserService:<br>    def create_user(self, user_data):<br>        # Validates user data<br>        if not user_data.email: raise ValueError("Email required")<br>        # Sends welcome email<br>        send_email(user_data.email, "Welcome!")<br>        # Saves to database<br>        return database.save_user(user_data)<br>``` | Split into separate services: Create `UserValidator`, `EmailService`, and `UserRepository` classes, then compose them in `UserService` that orchestrates the workflow but delegates specific responsibilities. |
| `ARCH-002` | Tight Coupling Between Components | Components directly depend on concrete implementations rather than abstractions, making the code difficult to test and modify. This violates dependency inversion principles. | Hard | ```python<br>class OrderProcessor:<br>    def __init__(self):<br>        self.payment = StripePaymentGateway()  # Hard dependency<br>        self.inventory = DatabaseInventory()   # Hard dependency<br>    <br>    def process_order(self, order):<br>        self.inventory.reserve_items(order.items)<br>        return self.payment.charge(order.total)<br>``` | Use dependency injection with interfaces: `def __init__(self, payment: PaymentGateway, inventory: InventoryService):` and define abstract base classes for PaymentGateway and InventoryService to allow different implementations. |
| `ARCH-003` | God Object Anti-pattern | A single class that knows too much or does too much, becoming overly complex and difficult to maintain. Often indicates poor separation of concerns and violation of multiple design principles. | Hard | ```python<br>class ApplicationManager:<br>    def __init__(self):<br>        self.users = {}<br>        self.orders = {}<br>        self.products = {}<br>    <br>    def create_user(self, data): pass<br>    def process_payment(self, order): pass<br>    def manage_inventory(self, product): pass<br>    def send_notifications(self, user): pass<br>    def generate_reports(self): pass<br>``` | Break into focused classes: `UserManager`, `OrderManager`, `ProductManager`, `PaymentProcessor`, `NotificationService`, and `ReportGenerator`. Use a dependency injection container to wire them together. |
| `ARCH-004` | Missing Abstraction Layer | Direct coupling to external services or frameworks without an abstraction layer, making the application dependent on specific implementations and difficult to test or change. | Medium | ```python<br>@app.get("/users/{user_id}")<br>def get_user(user_id: int):<br>    # Direct database coupling in controller<br>    result = database.execute("SELECT * FROM users WHERE id = %s", (user_id,))<br>    if not result:<br>        raise HTTPException(404, "User not found")<br>    return result[0]<br>``` | Create a repository layer: `class UserRepository: def get_by_id(self, user_id: int) -> Optional[User]:` and inject it into the endpoint. This separates data access logic from HTTP handling. |
| `ARCH-005` | Circular Dependencies | Two or more modules import each other, creating circular dependencies that can cause import errors and indicate poor module organization. | Hard | ```python<br># users.py<br>from orders import calculate_user_total<br><br>class User:<br>    def get_spending(self):<br>        return calculate_user_total(self.id)<br><br># orders.py<br>from users import User<br><br>def calculate_user_total(user_id):<br>    user = User.get_by_id(user_id)  # Circular import<br>    return sum(order.total for order in user.orders)<br>``` | Refactor to break the cycle: Move shared functionality to a separate module, use dependency injection, or restructure the code so that higher-level modules depend on lower-level ones without reciprocal dependencies. |
| `ARCH-006` | Inappropriate Use of Inheritance | Using inheritance when composition would be more appropriate, or creating deep inheritance hierarchies that are difficult to understand and maintain. | Medium | ```python<br>class DatabaseUser(User):<br>    def save(self): pass<br><br>class CachedDatabaseUser(DatabaseUser):<br>    def save(self): pass<br><br>class ValidatedCachedDatabaseUser(CachedDatabaseUser):<br>    def save(self): pass<br>``` | Use composition instead: Create `UserRepository`, `CacheService`, and `ValidationService` classes, then compose them: `class UserService: def __init__(self, repo, cache, validator):` to achieve the same functionality with better flexibility. |
| `ARCH-007` | Missing Design Patterns | Not using appropriate design patterns where they would significantly improve code organization, such as Factory patterns for object creation or Strategy patterns for algorithm selection. | Medium | ```python<br>def process_payment(payment_type: str, amount: float):<br>    if payment_type == "credit_card":<br>        # Credit card processing logic<br>        return charge_credit_card(amount)<br>    elif payment_type == "paypal":<br>        # PayPal processing logic<br>        return charge_paypal(amount)<br>    elif payment_type == "bank_transfer":<br>        # Bank transfer logic<br>        return process_bank_transfer(amount)<br>``` | Implement Strategy pattern: Create `PaymentStrategy` interface with implementations like `CreditCardStrategy`, `PayPalStrategy`, etc. Use a factory to create the appropriate strategy: `strategy = PaymentStrategyFactory.create(payment_type); return strategy.process(amount)`. |

## Business Logic & Requirement Mismatches

| Issue ID | Issue Name | Description | Difficulty | Flawed Python Snippet | Suggested Fix Description |
| :--- | :--- | :--- | :--- | :--- | :--- |
| `BIZ-001` | Incorrect Discount Calculation | The code implements a discount calculation but uses wrong constants, logic, or misses conditions specified in business requirements. The implementation appears correct syntactically but produces wrong business outcomes. | Hard | **Requirement:** "Premium users receive a 15% discount on orders over $100, but the total discount cannot exceed $50 per order."<br><br>```python<br>def calculate_price(price: float, is_premium: bool) -> float:<br>    if is_premium and price > 100:<br>        discount = price * 0.15<br>        return price - discount<br>    return price<br>``` | The code correctly calculates the 15% discount but fails to implement the $50 cap specified in the business requirements. Add logic to enforce the cap: `discount = min(price * 0.15, 50.0)` before applying it. |
| `BIZ-002` | Missing Business Rule Validation | The code processes data without enforcing critical business constraints, leading to invalid states that violate domain rules even though the code executes successfully. | Medium | **Requirement:** "Orders cannot be placed for out-of-stock items, and inventory must be reserved immediately upon order creation."<br><br>```python<br>@app.post("/orders/")<br>def create_order(order_data: OrderCreate):<br>    order = Order(**order_data.dict())<br>    order.status = "confirmed"<br>    return database.save_order(order)<br>``` | Add inventory validation before order creation: `for item in order_data.items: if not inventory.is_available(item.product_id, item.quantity): raise HTTPException(400, "Item out of stock"); inventory.reserve(item.product_id, item.quantity)` to enforce business constraints. |
| `BIZ-003` | Incorrect Status Workflow | The code allows state transitions that violate the defined business process workflow, potentially leading to invalid business states or operations. | Hard | **Requirement:** "Order status must follow the sequence: pending → confirmed → shipped → delivered. Orders can only be cancelled if they are pending or confirmed."<br><br>```python<br>@app.patch("/orders/{order_id}/cancel")<br>def cancel_order(order_id: int):<br>    order = database.get_order(order_id)<br>    order.status = "cancelled"<br>    return database.save_order(order)<br>``` | Add workflow validation: `if order.status not in ["pending", "confirmed"]: raise HTTPException(400, "Cannot cancel order in current status")` before allowing the status change to enforce the business workflow rules. |
| `BIZ-004` | Wrong Access Control Logic | The code implements access control but uses incorrect logic that doesn't match the specified business authorization rules, potentially allowing unauthorized access or denying legitimate access. | Medium | **Requirement:** "Users can edit posts they created, plus administrators can edit any post, but only within 24 hours of creation."<br><br>```python<br>@app.put("/posts/{post_id}")<br>def update_post(post_id: int, user: User = Depends(get_current_user)):<br>    post = database.get_post(post_id)<br>    if post.author_id == user.id or user.is_admin:<br>        return database.update_post(post_id, data)<br>    raise HTTPException(403, "Access denied")<br>``` | Add time constraint validation: `if datetime.now() - post.created_at > timedelta(hours=24): raise HTTPException(403, "Post can only be edited within 24 hours")` before the existing authorization check to enforce the business time limit. |
| `BIZ-005` | Incorrect Fee Calculation | The code calculates fees or charges using logic that doesn't match the specified business pricing model, resulting in incorrect financial transactions. | Hard | **Requirement:** "Transaction fees are 2.5% for amounts under $1000, 2.0% for amounts $1000-$5000, and 1.5% for amounts over $5000. Minimum fee is $0.50."<br><br>```python<br>def calculate_transaction_fee(amount: float) -> float:<br>    if amount < 1000:<br>        fee = amount * 0.025<br>    elif amount <= 5000:<br>        fee = amount * 0.020<br>    else:<br>        fee = amount * 0.015<br>    return fee<br>``` | Add minimum fee enforcement: `return max(fee, 0.50)` after calculating the percentage-based fee to ensure the minimum fee requirement is met as specified in the business rules. |
| `BIZ-006` | Missing Data Retention Policy | The code doesn't implement required data lifecycle management, violating business or regulatory requirements for data retention, archival, or deletion. | Medium | **Requirement:** "User account data must be permanently deleted 30 days after account deactivation, and all associated personal information must be anonymized."<br><br>```python<br>@app.delete("/users/{user_id}")<br>def deactivate_user(user_id: int):<br>    user = database.get_user(user_id)<br>    user.is_active = False<br>    user.deactivated_at = datetime.now()<br>    return database.save_user(user)<br>``` | Implement data retention logic: Add a background job or trigger that runs daily to check `if user.deactivated_at and datetime.now() - user.deactivated_at > timedelta(days=30): database.permanently_delete_user(user_id); database.anonymize_user_data(user_id)` to comply with data retention requirements. |
| `BIZ-007` | Incorrect Aggregation Logic | The code performs data aggregation or reporting calculations that don't align with the specified business metrics or KPI definitions, leading to incorrect business intelligence. | Medium | **Requirement:** "Monthly revenue should include only completed orders (status='delivered') and exclude refunded amounts. Subscription fees should be counted separately from product sales."<br><br>```python<br>def get_monthly_revenue(month: int, year: int) -> dict:<br>    orders = database.get_orders_by_month(month, year)<br>    total_revenue = sum(order.total for order in orders)<br>    return {"revenue": total_revenue}<br>``` | Fix aggregation logic: Filter and separate correctly: `completed_orders = [o for o in orders if o.status == 'delivered']; product_revenue = sum(o.total - o.refunded_amount for o in completed_orders if o.type == 'product'); subscription_revenue = sum(o.total for o in completed_orders if o.type == 'subscription')` to match business definitions. |

## Readability & Maintainability

| Issue ID | Issue Name | Description | Difficulty | Flawed Python Snippet | Suggested Fix Description |
| :--- | :--- | :--- | :--- | :--- | :--- |
| `READ-001` | Magic Numbers and Strings | Using literal numbers or strings throughout the code without explanation of their meaning, making the code difficult to understand and maintain. | Easy | ```python<br>@app.post("/upload")<br>def upload_file(file: UploadFile):<br>    if len(file.filename) > 255:<br>        raise HTTPException(400, "Filename too long")<br>    if file.size > 10485760:  # What is this number?<br>        raise HTTPException(413, "File too large")<br>    return process_file(file)<br>``` | Define named constants: `MAX_FILENAME_LENGTH = 255; MAX_FILE_SIZE = 10 * 1024 * 1024  # 10MB` and use them in the code: `if len(file.filename) > MAX_FILENAME_LENGTH:` to make the meaning clear. |
| `READ-002` | Poor Variable Naming | Using unclear, abbreviated, or misleading variable names that don't convey the variable's purpose or content, making code hard to read and understand. | Easy | ```python<br>def calc(u, o, t):<br>    r = u * 0.1<br>    if o > 100:<br>        r += (o - 100) * 0.05<br>    return r + t<br>``` | Use descriptive names: `def calculate_total_price(unit_price: float, quantity: int, tax: float) -> float: base_discount = unit_price * 0.1; bulk_discount = (quantity - 100) * 0.05 if quantity > 100 else 0; return base_discount + bulk_discount + tax` |
| `READ-003` | Excessive Function Length | Functions that are too long and do too many things, making them difficult to understand, test, and maintain. Long functions often indicate violation of single responsibility principle. | Medium | ```python<br>@app.post("/process-order")<br>def process_order(order_data: dict):<br>    # 50+ lines of validation logic<br>    if not order_data.get('email'): raise ValueError("Email required")<br>    if not validate_email(order_data['email']): raise ValueError("Invalid email")<br>    # 30+ lines of inventory checking<br>    for item in order_data['items']:<br>        if not check_inventory(item): raise ValueError("Out of stock")<br>    # 40+ lines of payment processing<br>    payment_result = process_payment(order_data['payment'])<br>    # 20+ lines of order creation and notification<br>    order = create_order(order_data)<br>    send_confirmation(order)<br>    return order<br>``` | Break into smaller functions: Create `validate_order_data()`, `check_order_inventory()`, `process_order_payment()`, and `finalize_order()` functions. The main function should orchestrate these steps: `validate_order_data(order_data); check_order_inventory(order_data); payment = process_order_payment(order_data); return finalize_order(order_data, payment)` |
| `READ-004` | Deep Nesting Levels | Code with excessive indentation levels due to nested if statements, loops, or try-catch blocks, making it difficult to follow the logic flow. | Medium | ```python<br>def process_users(users):<br>    for user in users:<br>        if user.is_active:<br>            if user.email_verified:<br>                if user.subscription:<br>                    if user.subscription.is_valid:<br>                        if user.preferences:<br>                            send_notification(user)<br>                        else:<br>                            create_default_preferences(user)<br>``` | Use early returns and guard clauses: `for user in users: if not user.is_active: continue; if not user.email_verified: continue; if not user.subscription or not user.subscription.is_valid: continue; if not user.preferences: create_default_preferences(user); else: send_notification(user)` |
| `READ-005` | Missing Documentation | Functions, classes, or modules without docstrings or comments explaining their purpose, parameters, return values, or complex logic. | Easy | ```python<br>def calculate_score(data, weights, threshold):<br>    total = sum(d * w for d, w in zip(data, weights))<br>    normalized = total / sum(weights)<br>    return 1.0 if normalized > threshold else normalized / threshold<br>``` | Add comprehensive docstring: `"""Calculate weighted score with threshold normalization. Args: data: List of numeric values to score; weights: List of weight values for each data point; threshold: Minimum value for full score (1.0). Returns: float: Normalized score between 0.0 and 1.0"""` |
| `READ-006` | Inconsistent Code Style | Mixing different coding styles, naming conventions, or formatting patterns within the same codebase, making it harder to read and maintain. | Easy | ```python<br>class user_manager:  # snake_case class name<br>    def GetUser(self, userId):  # PascalCase method, camelCase param<br>        user_data=database.fetch_user(userId)  # No spaces around =<br>        if user_data is None:<br>                return None  # Inconsistent indentation<br>        return user_data<br>``` | Follow consistent Python conventions: `class UserManager: def get_user(self, user_id: int) -> Optional[User]: user_data = database.fetch_user(user_id); if user_data is None: return None; return user_data` using PascalCase for classes, snake_case for functions/variables, and consistent spacing. |
| `READ-007` | Complex Conditional Expressions | Using overly complex boolean expressions or nested conditionals that are difficult to understand and evaluate. This often indicates a need for intermediate variables or helper functions. | Medium | ```python<br>@app.get("/posts")<br>def get_posts(user: User = Depends(get_current_user)):<br>    if (user.is_admin or (user.is_verified and user.subscription and user.subscription.plan in ['premium', 'enterprise'] and user.created_at < datetime.now() - timedelta(days=30))) and not user.is_banned:<br>        return get_all_posts()<br>    return get_public_posts()<br>``` | Break complex conditions into readable parts: `is_premium_user = user.subscription and user.subscription.plan in ['premium', 'enterprise']; is_long_time_user = user.created_at < datetime.now() - timedelta(days=30); can_see_all = user.is_admin or (user.is_verified and is_premium_user and is_long_time_user); if can_see_all and not user.is_banned: return get_all_posts()` |

## Python Best Practices & Idioms

| Issue ID | Issue Name | Description | Difficulty | Flawed Python Snippet | Suggested Fix Description |
| :--- | :--- | :--- | :--- | :--- | :--- |
| `PY-001` | Not Using Context Managers | Failing to use context managers for resource management, potentially leading to resource leaks when files, connections, or locks are not properly closed or released. | Easy | ```python<br>@app.get("/read-config")<br>def read_config():<br>    file = open("config.json", "r")<br>    data = json.load(file)<br>    file.close()  # May not execute if exception occurs<br>    return data<br>``` | Use context manager: `with open("config.json", "r") as file: data = json.load(file); return data` to ensure the file is properly closed even if an exception occurs. |
| `PY-002` | Inefficient Dictionary Operations | Using inefficient dictionary access patterns, such as checking key existence separately from accessing values, or not using dictionary methods like get() with defaults. | Easy | ```python<br>def get_user_setting(user_id: int, setting_name: str):<br>    settings = get_user_settings(user_id)<br>    if setting_name in settings:<br>        return settings[setting_name]<br>    else:<br>        return "default_value"<br>``` | Use dict.get() with default: `return settings.get(setting_name, "default_value")` for more concise and efficient dictionary access with fallback values. |
| `PY-003` | Not Using List Comprehensions | Using verbose loops with append operations when list comprehensions would be more Pythonic, readable, and often more efficient. | Easy | ```python<br>@app.get("/active-users")<br>def get_active_users():<br>    all_users = database.get_all_users()<br>    active_users = []<br>    for user in all_users:<br>        if user.is_active:<br>            active_users.append(user.email)<br>    return active_users<br>``` | Use list comprehension: `active_users = [user.email for user in database.get_all_users() if user.is_active]` for more concise and Pythonic code. |
| `PY-004` | Improper Exception Chaining | Not properly chaining exceptions when wrapping or re-raising them, losing valuable debugging information about the original cause of the error. | Medium | ```python<br>@app.get("/data/{file_id}")<br>def get_data(file_id: str):<br>    try:<br>        return load_file_data(file_id)<br>    except FileNotFoundError:<br>        raise HTTPException(404, "Data not found")  # Lost original exception<br>``` | Chain exceptions properly: `except FileNotFoundError as e: raise HTTPException(404, "Data not found") from e` to preserve the original exception information for debugging while providing a clean API response. |
| `PY-005` | Not Using Enum for Constants | Using string literals or magic numbers for status values, types, or other constants instead of using Python's Enum class for better type safety and maintainability. | Medium | ```python<br>@app.post("/orders/")<br>def create_order(order: OrderCreate):<br>    new_order = Order(**order.dict())<br>    new_order.status = "pending"  # Magic string<br>    if validate_payment(order.payment):<br>        new_order.status = "confirmed"  # Another magic string<br>    return new_order<br>``` | Use Enum: `from enum import Enum; class OrderStatus(Enum): PENDING = "pending"; CONFIRMED = "confirmed"; CANCELLED = "cancelled"` then use `new_order.status = OrderStatus.PENDING.value` for type-safe constant values. |
| `PY-006` | Ignoring Pythonic Iteration | Using index-based loops when more Pythonic iteration methods are available, such as enumerate() for index tracking or zip() for parallel iteration. | Easy | ```python<br>def process_user_scores(users, scores):<br>    results = []<br>    for i in range(len(users)):<br>        user = users[i]<br>        score = scores[i]<br>        results.append(f"{user.name}: {score}")<br>    return results<br>``` | Use zip() for parallel iteration: `return [f"{user.name}: {score}" for user, score in zip(users, scores)]` which is more readable and handles mismatched list lengths gracefully. |
| `PY-007` | Not Using Type Hints | Missing type annotations on function parameters and return values, reducing code clarity and preventing static type checking tools from catching potential errors. | Medium | ```python<br>@app.post("/calculate")<br>def calculate_discount(base_price, discount_percent, user_level):<br>    if user_level == "premium":<br>        discount_percent += 5<br>    return base_price * (1 - discount_percent / 100)<br>``` | Add comprehensive type hints: `from typing import Literal; @app.post("/calculate") def calculate_discount(base_price: float, discount_percent: float, user_level: Literal["basic", "premium"]) -> float:` to improve code clarity and enable static analysis. |

## Testing & Reliability

| Issue ID | Issue Name | Description | Difficulty | Flawed Python Snippet | Suggested Fix Description |
| :--- | :--- | :--- | :--- | :--- | :--- |
| `TEST-001` | Missing Unit Tests | Critical business logic functions without corresponding unit tests, making it difficult to verify correctness and catch regressions during development. | Medium | ```python<br>def calculate_shipping_cost(weight: float, distance: float, express: bool = False) -> float:<br>    base_cost = weight * 0.1 + distance * 0.05<br>    if express:<br>        base_cost *= 1.5<br>    return round(base_cost, 2)<br><br># No corresponding test file or test cases<br>``` | Create comprehensive unit tests: `def test_calculate_shipping_cost(): assert calculate_shipping_cost(10, 100, False) == 6.0; assert calculate_shipping_cost(10, 100, True) == 9.0; assert calculate_shipping_cost(0, 0, False) == 0.0` covering normal cases, edge cases, and boundary conditions. |
| `TEST-002` | Insufficient Error Testing | Tests that only cover successful scenarios without testing error conditions, edge cases, or failure modes that the application should handle gracefully. | Hard | ```python<br>def test_user_creation():<br>    user_data = {"name": "John", "email": "john@example.com"}<br>    result = create_user(user_data)<br>    assert result["status"] == "success"<br>    # Missing tests for: invalid email, duplicate email, missing fields, etc.<br>``` | Add error case tests: `def test_user_creation_invalid_email(): with pytest.raises(ValidationError): create_user({"name": "John", "email": "invalid"}); def test_user_creation_duplicate_email(): create_user(valid_data); with pytest.raises(DuplicateError): create_user(valid_data)` to ensure robust error handling. |
| `TEST-003` | Test Dependencies and Order | Tests that depend on other tests to run first or that fail when run in isolation, indicating poor test isolation and making the test suite unreliable. | Hard | ```python<br>def test_create_user():<br>    global created_user_id<br>    user = create_user({"name": "Test User"})<br>    created_user_id = user.id<br><br>def test_get_user():<br>    # Depends on test_create_user running first<br>    user = get_user(created_user_id)<br>    assert user.name == "Test User"<br>``` | Make tests independent: `@pytest.fixture def sample_user(): return create_user({"name": "Test User"}); def test_get_user(sample_user): user = get_user(sample_user.id); assert user.name == "Test User"` using fixtures to set up required state for each test. |
| `TEST-004` | Mocking External Dependencies | Tests that make real calls to external services, databases, or APIs instead of using mocks, making tests slow, flaky, and dependent on external systems. | Medium | ```python<br>def test_send_welcome_email():<br>    user = {"email": "test@example.com", "name": "Test"}<br>    # This makes a real API call to email service<br>    result = send_welcome_email(user)<br>    assert result.status_code == 200<br>``` | Use mocks for external calls: `@patch('email_service.send_email') def test_send_welcome_email(mock_send): mock_send.return_value = Mock(status_code=200); result = send_welcome_email(user); mock_send.assert_called_once_with("test@example.com", "Welcome!", ANY)` to isolate the unit under test. |
| `TEST-005` | Inadequate Test Coverage | Missing tests for important code paths, especially error handling, edge cases, and complex conditional logic, leading to undetected bugs in production. | Hard | ```python<br>def process_payment(amount: float, payment_method: str) -> dict:<br>    if amount <= 0:<br>        raise ValueError("Invalid amount")<br>    if payment_method == "credit_card":<br>        return charge_credit_card(amount)<br>    elif payment_method == "paypal":<br>        return charge_paypal(amount)<br>    else:<br>        return {"status": "unsupported_method"}<br><br># Tests only cover credit_card path, missing other branches<br>``` | Test all code paths: Add tests for PayPal path, unsupported method path, and edge cases: `def test_process_payment_paypal(); def test_process_payment_unsupported(); def test_process_payment_negative_amount()` to ensure comprehensive coverage of all execution paths. |
| `TEST-006` | Flaky Tests | Tests that sometimes pass and sometimes fail without code changes, often due to timing issues, race conditions, or dependencies on external state. | Hard | ```python<br>@pytest.mark.asyncio<br>async def test_async_operation():<br>    task = asyncio.create_task(long_running_operation())<br>    await asyncio.sleep(0.1)  # Arbitrary wait time<br>    assert task.done()  # May fail if operation takes longer<br>``` | Make tests deterministic: `@pytest.mark.asyncio async def test_async_operation(): result = await long_running_operation(); assert result.status == "completed"` or use proper synchronization: `await asyncio.wait_for(task, timeout=5.0)` instead of arbitrary sleeps. |
| `TEST-007` | Poor Test Data Management | Using hard-coded test data or not properly cleaning up test data, leading to tests that interfere with each other or become difficult to maintain as the schema evolves. | Medium | ```python<br>def test_user_operations():<br>    # Hard-coded data that may become invalid<br>    user_id = 12345<br>    user = get_user(user_id)  # Assumes user exists<br>    assert user.name == "Fixed Test User"<br>    # No cleanup - user remains in system<br>``` | Use proper test data management: `@pytest.fixture def test_user(): user = create_test_user({"name": "Test User"}); yield user; cleanup_test_user(user.id); def test_user_operations(test_user): assert test_user.name == "Test User"` with fixtures that create and clean up test data automatically. |

---

## Taxonomy Summary

This comprehensive taxonomy contains **9 categories** with **7 defects each**, totaling **63 distinct software defects** commonly found in Python web applications:

### Category Overview:

1. **Correctness & Logic Errors** (LOG-001 to LOG-007): Fundamental programming logic issues
2. **Security Vulnerabilities** (SEC-001 to SEC-007): Security-related flaws and vulnerabilities  
3. **Performance Issues** (PERF-001 to PERF-007): Performance bottlenecks and inefficiencies
4. **Concurrency & Asynchronous Code Issues** (ASYNC-001 to ASYNC-007): Async programming problems
5. **Code Architecture & Design Patterns** (ARCH-001 to ARCH-007): Structural and design issues
6. **Business Logic & Requirement Mismatches** (BIZ-001 to BIZ-007): Requirement implementation errors
7. **Readability & Maintainability** (READ-001 to READ-007): Code quality and maintenance issues
8. **Python Best Practices & Idioms** (PY-001 to PY-007): Python-specific coding practices
9. **Testing & Reliability** (TEST-001 to TEST-007): Testing and quality assurance issues

### Difficulty Distribution:
- **Easy**: 21 issues (33.3%) - Readily identifiable by human reviewers
- **Medium**: 21 issues (33.3%) - Require domain knowledge to spot
- **Hard**: 21 issues (33.3%) - Require deep expertise and context understanding

This taxonomy serves as the **gold standard benchmark** for evaluating AI code review agents across the full spectrum of software defects commonly encountered in production Python web applications.