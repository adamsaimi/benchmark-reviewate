[
  {
    "issue_id": "LOG-001",
    "issue_name": "Off-by-One Error",
    "category": "Correctness & Logic Errors",
    "description": "This occurs when a loop iterates one time too many or too few. It's a common mistake with loop conditions, often leading to `IndexError` exceptions or silently missed data processing.",
    "difficulty": "Easy",
    "requirement": null,
    "flawed_snippet": "items = [10, 20, 30]\nfor i in range(len(items) + 1):\n    if i < len(items):\n        print(items[i])",
    "suggested_fix": "The loop condition `range(len(items) + 1)` should be changed to `range(len(items))` to prevent iterating beyond the list's bounds.",
    "file_target": "benchmark/services/post_service.py",
    "generated": true,
    "error": null
  },
  {
    "issue_id": "LOG-002",
    "issue_name": "Incorrect Boolean Logic",
    "category": "Correctness & Logic Errors",
    "description": "Occurs when logical operators (and/or) are misused or when boolean conditions are negated incorrectly. This can lead to incorrect conditional execution and unexpected behavior in API endpoints.",
    "difficulty": "Medium",
    "requirement": null,
    "flawed_snippet": "@app.post(\"/users/\")\ndef create_user(user: User):\n    if not user.email or not user.password:\n        # Should be 'and' not 'or'\n        raise HTTPException(400, \"Missing credentials\")\n    return create_user_account(user)",
    "suggested_fix": "Change the condition to `if not user.email and not user.password:` or better yet, `if not (user.email and user.password):` to correctly validate that both fields are present.",
    "file_target": "benchmark/routers/posts.py",
    "generated": true,
    "error": null
  },
  {
    "issue_id": "LOG-003",
    "issue_name": "Unhandled None Values",
    "category": "Correctness & Logic Errors",
    "description": "Failure to check for None values before accessing attributes or methods, leading to `AttributeError` exceptions. Common in API responses and database query results.",
    "difficulty": "Easy",
    "requirement": null,
    "flawed_snippet": "def get_user_profile(user_id: int):\n    user = database.get_user(user_id)\n    return {\n        \"name\": user.name,\n        \"email\": user.email.lower()\n    }",
    "suggested_fix": "Add a null check: `if user is None: raise HTTPException(404, \"User not found\")` before accessing user attributes to handle cases where the database query returns None.",
    "file_target": "benchmark/services/post_service.py",
    "generated": true,
    "error": "Command '['git', 'commit', '-m', 'feat(benchmark): Introduce LOG-003 - Unhandled None Values']' returned non-zero exit status 128."
  },
  {
    "issue_id": "LOG-004",
    "issue_name": "Incorrect Exception Handling",
    "category": "Correctness & Logic Errors",
    "description": "Catching overly broad exceptions or failing to handle specific exception types appropriately. This can mask important errors and make debugging difficult.",
    "difficulty": "Medium",
    "requirement": null,
    "flawed_snippet": "@app.get(\"/data/{file_id}\")\ndef get_data(file_id: str):\n    try:\n        with open(f\"data/{file_id}.json\") as f:\n            return json.load(f)\n    except Exception:\n        return {\"error\": \"File not found\"}",
    "suggested_fix": "Replace the broad `except Exception:` with specific exceptions like `except (FileNotFoundError, JSONDecodeError):` and handle each appropriately with different HTTP status codes.",
    "file_target": "benchmark/routers/posts.py",
    "generated": true,
    "error": "Command '['git', 'commit', '-m', 'feat(benchmark): Introduce LOG-004 - Incorrect Exception Handling']' returned non-zero exit status 128."
  },
  {
    "issue_id": "LOG-005",
    "issue_name": "Mutable Default Arguments",
    "category": "Correctness & Logic Errors",
    "description": "Using mutable objects (lists, dictionaries) as default function arguments, causing shared state between function calls. This leads to unexpected behavior where modifications persist across calls.",
    "difficulty": "Hard",
    "requirement": null,
    "flawed_snippet": "def add_tag(post_id: int, tag: str, tags=[]):\n    tags.append(tag)\n    return update_post_tags(post_id, tags)",
    "suggested_fix": "Change the default argument to `tags=None` and initialize inside the function: `if tags is None: tags = []` to ensure each function call gets a fresh list.",
    "file_target": "benchmark/services/post_service.py",
    "generated": true,
    "error": "Command '['git', 'commit', '-m', 'feat(benchmark): Introduce LOG-005 - Mutable Default Arguments']' returned non-zero exit status 128."
  },
  {
    "issue_id": "LOG-006",
    "issue_name": "Integer Division Error",
    "category": "Correctness & Logic Errors",
    "description": "Using floor division (`//`) when true division (`/`) is needed, or vice versa. This is particularly problematic in calculations involving rates, percentages, or pagination logic.",
    "difficulty": "Medium",
    "requirement": null,
    "flawed_snippet": "@app.get(\"/posts/\")\ndef get_posts(page: int = 1, per_page: int = 10):\n    total_posts = get_total_post_count()\n    total_pages = total_posts // per_page\n    return {\"posts\": get_posts_slice(page), \"total_pages\": total_pages}",
    "suggested_fix": "Use proper ceiling division: `import math; total_pages = math.ceil(total_posts / per_page)` to ensure the last page is included even when it's not completely full.",
    "file_target": "benchmark/routers/posts.py",
    "generated": true,
    "error": "Command '['git', 'commit', '-m', 'feat(benchmark): Introduce LOG-006 - Integer Division Error']' returned non-zero exit status 128."
  },
  {
    "issue_id": "LOG-007",
    "issue_name": "Incorrect String Comparison",
    "category": "Correctness & Logic Errors",
    "description": "Performing case-sensitive string comparisons when case-insensitive comparison is needed, or failing to normalize strings before comparison. Common in email validation and search functionality.",
    "difficulty": "Easy",
    "requirement": null,
    "flawed_snippet": "def authenticate_user(email: str, password: str):\n    user = get_user_by_email(email)\n    if user and user.email == email:\n        return verify_password(user, password)\n    return False",
    "suggested_fix": "Normalize the email comparison: `if user and user.email.lower() == email.lower():` to handle cases where the stored email and provided email have different capitalizations.",
    "file_target": "benchmark/services/post_service.py",
    "generated": true,
    "error": null
  },
  {
    "issue_id": "SEC-001",
    "issue_name": "SQL Injection Vulnerability",
    "category": "Security Vulnerabilities",
    "description": "Occurs when user input is directly concatenated into SQL queries without proper sanitization. This allows attackers to manipulate database queries and potentially access or modify unauthorized data.",
    "difficulty": "Hard",
    "requirement": null,
    "flawed_snippet": "@app.get(\"/users/search\")\ndef search_users(name: str):\n    query = f\"SELECT * FROM users WHERE name = '{name}'\"\n    return database.execute(query)",
    "suggested_fix": "Use parameterized queries or an ORM: `query = \"SELECT * FROM users WHERE name = %s\"; database.execute(query, (name,))` to prevent SQL injection attacks.",
    "file_target": "benchmark/services/post_service.py",
    "generated": true,
    "error": null
  },
  {
    "issue_id": "SEC-002",
    "issue_name": "Hardcoded Credentials",
    "category": "Security Vulnerabilities",
    "description": "Sensitive information like API keys, passwords, or tokens are hardcoded in the source code. This exposes credentials to anyone with access to the codebase and makes credential rotation difficult.",
    "difficulty": "Easy",
    "requirement": null,
    "flawed_snippet": "DATABASE_URL = \"postgresql://admin:secret123@localhost/mydb\"\nAPI_SECRET_KEY = \"super-secret-key-12345\"\n\napp = FastAPI()",
    "suggested_fix": "Move credentials to environment variables: `DATABASE_URL = os.getenv(\"DATABASE_URL\")` and `API_SECRET_KEY = os.getenv(\"API_SECRET_KEY\")` and store them in a `.env` file or deployment configuration.",
    "file_target": "benchmark/config.py",
    "generated": true,
    "error": ""
  },
  {
    "issue_id": "SEC-003",
    "issue_name": "Missing Input Validation",
    "category": "Security Vulnerabilities",
    "description": "Failing to validate user input for type, length, format, or malicious content. This can lead to various attacks including XSS, injection attacks, and system crashes.",
    "difficulty": "Medium",
    "requirement": null,
    "flawed_snippet": "@app.post(\"/upload\")\ndef upload_file(filename: str, content: str):\n    with open(f\"uploads/{filename}\", \"w\") as f:\n        f.write(content)\n    return {\"status\": \"uploaded\"}",
    "suggested_fix": "Add input validation: check filename for path traversal (`../`), validate file extensions, limit content size, and sanitize the filename using `os.path.basename()` and allowlist validation.",
    "file_target": "benchmark/routers/posts.py",
    "generated": true,
    "error": null
  },
  {
    "issue_id": "SEC-004",
    "issue_name": "Insecure Random Number Generation",
    "category": "Security Vulnerabilities",
    "description": "Using predictable random number generators for security-sensitive operations like token generation, session IDs, or cryptographic nonces. This makes the system vulnerable to prediction attacks.",
    "difficulty": "Hard",
    "requirement": null,
    "flawed_snippet": "import random\n\ndef generate_session_token():\n    return ''.join(random.choices('abcdef0123456789', k=32))",
    "suggested_fix": "Use cryptographically secure random generation: `import secrets; return secrets.token_hex(16)` for generating unpredictable tokens suitable for security purposes.",
    "file_target": "benchmark/services/post_service.py",
    "generated": true,
    "error": null
  },
  {
    "issue_id": "SEC-005",
    "issue_name": "Information Disclosure",
    "category": "Security Vulnerabilities",
    "description": "Returning sensitive information in error messages, logs, or API responses that could help attackers understand the system structure or gain unauthorized access.",
    "difficulty": "Medium",
    "requirement": null,
    "flawed_snippet": "@app.post(\"/login\")\ndef login(credentials: LoginRequest):\n    try:\n        user = authenticate(credentials.email, credentials.password)\n        return {\"token\": create_token(user)}\n    except DatabaseError as e:\n        raise HTTPException(500, f\"Database error: {str(e)}\")",
    "suggested_fix": "Return generic error messages: `raise HTTPException(500, \"Internal server error\")` and log the detailed error internally without exposing it to the client.",
    "file_target": "benchmark/routers/posts.py",
    "generated": true,
    "error": ""
  },
  {
    "issue_id": "SEC-006",
    "issue_name": "Missing Authentication Check",
    "category": "Security Vulnerabilities",
    "description": "API endpoints that should require authentication are accessible without proper authentication checks. This allows unauthorized access to protected resources.",
    "difficulty": "Easy",
    "requirement": null,
    "flawed_snippet": "@app.delete(\"/admin/users/{user_id}\")\ndef delete_user(user_id: int):\n    database.delete_user(user_id)\n    return {\"status\": \"deleted\"}",
    "suggested_fix": "Add authentication dependency: `@app.delete(\"/admin/users/{user_id}\") def delete_user(user_id: int, current_user: User = Depends(get_current_admin)):` to ensure only authenticated admin users can access this endpoint.",
    "file_target": "benchmark/routers/posts.py",
    "generated": true,
    "error": null
  },
  {
    "issue_id": "SEC-007",
    "issue_name": "Insufficient Authorization",
    "category": "Security Vulnerabilities",
    "description": "Users can access or modify resources they shouldn't have access to. The system checks if a user is authenticated but not if they have permission for the specific resource.",
    "difficulty": "Hard",
    "requirement": null,
    "flawed_snippet": "@app.get(\"/posts/{post_id}\")\ndef get_post(post_id: int, user: User = Depends(get_current_user)):\n    post = database.get_post(post_id)\n    return post",
    "suggested_fix": "Add authorization check: `if post.is_private and post.author_id != user.id: raise HTTPException(403, \"Access denied\")` to ensure users can only access posts they own or public posts.",
    "file_target": "benchmark/routers/posts.py",
    "generated": true,
    "error": ""
  },
  {
    "issue_id": "PERF-001",
    "issue_name": "N+1 Query Problem",
    "category": "Performance Issues",
    "description": "Making multiple database queries in a loop instead of using a single query with joins or bulk operations. This creates significant performance overhead as the dataset grows.",
    "difficulty": "Hard",
    "requirement": null,
    "flawed_snippet": "@app.get(\"/users/with-posts\")\ndef get_users_with_posts():\n    users = database.get_all_users()\n    result = []\n    for user in users:\n        posts = database.get_posts_by_user(user.id)\n        result.append({\"user\": user, \"posts\": posts})\n    return result",
    "suggested_fix": "Use a single query with joins or eager loading: `users = database.get_users_with_posts()` or use an ORM feature like SQLAlchemy's `joinedload()` to fetch all related data in one query.",
    "file_target": "benchmark/services/post_service.py",
    "generated": true,
    "error": ""
  },
  {
    "issue_id": "PERF-002",
    "issue_name": "Missing Database Indexes",
    "category": "Performance Issues",
    "description": "Querying database columns that are frequently used in WHERE clauses without proper indexes, leading to full table scans and poor performance.",
    "difficulty": "Medium",
    "requirement": null,
    "flawed_snippet": "# Database schema missing index\n@app.get(\"/posts/by-author\")\ndef get_posts_by_author(author_email: str):\n    # This query will scan the entire posts table\n    return database.query(\"SELECT * FROM posts WHERE author_email = %s\", author_email)",
    "suggested_fix": "Add a database index: `CREATE INDEX idx_posts_author_email ON posts(author_email);` to optimize queries that filter by author_email. Also consider composite indexes for multi-column queries.",
    "file_target": "benchmark/services/post_service.py",
    "generated": true,
    "error": null
  },
  {
    "issue_id": "PERF-003",
    "issue_name": "Inefficient List Operations",
    "category": "Performance Issues",
    "description": "Using inefficient operations like repeated list concatenation, searching unsorted lists, or checking membership in lists instead of using appropriate data structures.",
    "difficulty": "Easy",
    "requirement": null,
    "flawed_snippet": "@app.post(\"/tags/bulk-check\")\ndef check_tags_exist(tag_names: List[str]):\n    existing_tags = database.get_all_tag_names()  # Returns list\n    result = []\n    for tag in tag_names:\n        if tag in existing_tags:  # O(n) lookup in list\n            result.append(tag)\n    return result",
    "suggested_fix": "Convert the list to a set for O(1) lookups: `existing_tags_set = set(database.get_all_tag_names())` and then use `if tag in existing_tags_set:` for much faster membership testing.",
    "file_target": "benchmark/routers/posts.py",
    "generated": true,
    "error": null
  },
  {
    "issue_id": "PERF-004",
    "issue_name": "Unnecessary Object Creation",
    "category": "Performance Issues",
    "description": "Creating objects or performing expensive operations inside loops or frequently called functions when they could be cached or computed once.",
    "difficulty": "Medium",
    "requirement": null,
    "flawed_snippet": "@app.get(\"/posts/{post_id}/formatted\")\ndef get_formatted_post(post_id: int):\n    post = database.get_post(post_id)\n    formatter = PostFormatter()  # Created on every request\n    formatter.configure(load_settings())  # Loads from disk\n    return formatter.format(post)",
    "suggested_fix": "Cache expensive objects: use a module-level formatter `_formatter = PostFormatter()` and configure it once at startup, or use dependency injection with a singleton scope for the formatter.",
    "file_target": "benchmark/routers/posts.py",
    "generated": true,
    "error": null
  },
  {
    "issue_id": "PERF-005",
    "issue_name": "Blocking I/O in Async Context",
    "category": "Performance Issues",
    "description": "Using synchronous I/O operations in async functions, which blocks the event loop and prevents concurrent request handling. This negates the benefits of async programming.",
    "difficulty": "Hard",
    "requirement": null,
    "flawed_snippet": "@app.get(\"/external-data\")\nasync def get_external_data():\n    # Blocking synchronous HTTP call in async function\n    response = requests.get(\"https://api.example.com/data\")\n    return response.json()",
    "suggested_fix": "Use async HTTP client: `import httpx; async with httpx.AsyncClient() as client: response = await client.get(\"https://api.example.com/data\")` to maintain async behavior throughout the request pipeline.",
    "file_target": "benchmark/routers/posts.py",
    "generated": true,
    "error": null
  },
  {
    "issue_id": "PERF-006",
    "issue_name": "Memory Leak in Generator Usage",
    "category": "Performance Issues",
    "description": "Not properly closing generators or iterators, or keeping references to large objects longer than necessary, leading to memory accumulation over time.",
    "difficulty": "Hard",
    "requirement": null,
    "flawed_snippet": "@app.get(\"/large-dataset\")\ndef process_large_dataset():\n    data = database.get_all_records()  # Loads everything into memory\n    processed = [expensive_transform(item) for item in data]\n    return {\"count\": len(processed)}",
    "suggested_fix": "Use generators and streaming: `def process_records(): for record in database.stream_records(): yield expensive_transform(record)` and process items one at a time without loading everything into memory.",
    "file_target": "benchmark/services/post_service.py",
    "generated": true,
    "error": null
  },
  {
    "issue_id": "PERF-007",
    "issue_name": "Inefficient JSON Serialization",
    "category": "Performance Issues",
    "description": "Using default Python JSON serialization for complex objects or large datasets without considering performance implications. Can be particularly slow for datetime objects and nested structures.",
    "difficulty": "Medium",
    "requirement": null,
    "flawed_snippet": "@app.get(\"/reports/detailed\")\ndef get_detailed_report():\n    data = get_complex_report_data()  # Returns objects with datetimes\n    return json.dumps(data, default=str)  # Slow default serialization",
    "suggested_fix": "Use faster JSON libraries: `import orjson; return orjson.dumps(data)` or optimize the default serializer by implementing custom serialization methods for datetime and other frequent types.",
    "file_target": "benchmark/routers/posts.py",
    "generated": true,
    "error": ""
  },
  {
    "issue_id": "ASYNC-001",
    "issue_name": "Mixing Sync and Async Code",
    "category": "Concurrency & Asynchronous Code Issues",
    "description": "Calling synchronous functions within async functions without proper handling, which can block the event loop and degrade performance in concurrent scenarios.",
    "difficulty": "Medium",
    "requirement": null,
    "flawed_snippet": "@app.get(\"/user-data\")\nasync def get_user_data(user_id: int):\n    user = database.get_user_sync(user_id)  # Blocks event loop\n    return {\"user\": user, \"timestamp\": time.time()}",
    "suggested_fix": "Use async database operations: `user = await database.get_user_async(user_id)` or if sync is necessary, use `user = await asyncio.to_thread(database.get_user_sync, user_id)` to run in a thread pool.",
    "file_target": "benchmark/routers/posts.py",
    "generated": true,
    "error": ""
  },
  {
    "issue_id": "ASYNC-002",
    "issue_name": "Race Condition in Shared State",
    "category": "Concurrency & Asynchronous Code Issues",
    "description": "Multiple async operations modifying shared state without proper synchronization, leading to inconsistent data and unpredictable behavior in concurrent environments.",
    "difficulty": "Hard",
    "requirement": null,
    "flawed_snippet": "counter = 0\n\n@app.post(\"/increment\")\nasync def increment():\n    global counter\n    current = counter\n    await asyncio.sleep(0.1)  # Simulates async operation\n    counter = current + 1\n    return {\"counter\": counter}",
    "suggested_fix": "Use proper synchronization: `import asyncio; lock = asyncio.Lock()` then `async with lock: current = counter; await asyncio.sleep(0.1); counter = current + 1` to ensure atomic updates.",
    "file_target": "benchmark/routers/posts.py",
    "generated": true,
    "error": null
  },
  {
    "issue_id": "ASYNC-003",
    "issue_name": "Forgotten Await Statement",
    "category": "Concurrency & Asynchronous Code Issues",
    "description": "Calling async functions without the await keyword, causing the function to return a coroutine object instead of the expected result. This is a common source of bugs in async code.",
    "difficulty": "Easy",
    "requirement": null,
    "flawed_snippet": "async def send_notification(user_id: int, message: str):\n    return email_service.send_async(user_id, message)\n\n@app.post(\"/notify\")\nasync def notify_user(user_id: int, message: str):\n    result = send_notification(user_id, message)  # Missing await\n    return {\"sent\": bool(result)}",
    "suggested_fix": "Add the await keyword: `result = await send_notification(user_id, message)` to properly wait for the async operation to complete and get the actual result.",
    "file_target": "benchmark/routers/posts.py",
    "generated": true,
    "error": null
  },
  {
    "issue_id": "ASYNC-004",
    "issue_name": "Improper Exception Handling in Async",
    "category": "Concurrency & Asynchronous Code Issues",
    "description": "Not properly handling exceptions in async operations, especially in fire-and-forget tasks or when using asyncio.gather(). Unhandled exceptions can crash the application.",
    "difficulty": "Hard",
    "requirement": null,
    "flawed_snippet": "@app.post(\"/batch-process\")\nasync def batch_process(items: List[str]):\n    tasks = [process_item_async(item) for item in items]\n    await asyncio.gather(*tasks)  # Exceptions will propagate\n    return {\"status\": \"completed\"}",
    "suggested_fix": "Handle exceptions properly: `await asyncio.gather(*tasks, return_exceptions=True)` and check results, or wrap each task: `tasks = [safe_process_item(item) for item in items]` where safe_process_item catches and logs exceptions.",
    "file_target": "benchmark/routers/posts.py",
    "generated": true,
    "error": null
  },
  {
    "issue_id": "ASYNC-005",
    "issue_name": "Blocking Operations in Event Loop",
    "category": "Concurrency & Asynchronous Code Issues",
    "description": "Performing CPU-intensive or blocking operations directly in async functions, which prevents other async operations from running and degrades overall application performance.",
    "difficulty": "Medium",
    "requirement": null,
    "flawed_snippet": "@app.post(\"/calculate\")\nasync def heavy_calculation(data: List[int]):\n    # CPU-intensive operation blocking event loop\n    result = sum(x ** 2 for x in data if x > 1000)\n    return {\"result\": result}",
    "suggested_fix": "Use thread pool for CPU-bound work: `import asyncio; result = await asyncio.to_thread(lambda: sum(x ** 2 for x in data if x > 1000))` to prevent blocking the event loop.",
    "file_target": "benchmark/routers/posts.py",
    "generated": true,
    "error": null
  },
  {
    "issue_id": "ASYNC-006",
    "issue_name": "Improper Task Creation",
    "category": "Concurrency & Asynchronous Code Issues",
    "description": "Creating tasks without proper lifecycle management, leading to memory leaks or zombie tasks that continue running after they're no longer needed.",
    "difficulty": "Hard",
    "requirement": null,
    "flawed_snippet": "@app.post(\"/start-background-job\")\nasync def start_job(job_id: str):\n    asyncio.create_task(long_running_job(job_id))  # Fire and forget, no cleanup\n    return {\"status\": \"started\"}",
    "suggested_fix": "Manage task lifecycle: `task = asyncio.create_task(long_running_job(job_id)); background_tasks.add(task); task.add_done_callback(background_tasks.discard)` to track and clean up tasks properly.",
    "file_target": "benchmark/routers/posts.py",
    "generated": true,
    "error": null
  },
  {
    "issue_id": "ASYNC-007",
    "issue_name": "Deadlock in Async Locks",
    "category": "Concurrency & Asynchronous Code Issues",
    "description": "Acquiring multiple locks in different orders or holding locks across await points can lead to deadlocks in async applications. This is particularly problematic in complex async workflows.",
    "difficulty": "Hard",
    "requirement": null,
    "flawed_snippet": "lock_a = asyncio.Lock()\nlock_b = asyncio.Lock()\n\nasync def operation_1():\n    async with lock_a:\n        await asyncio.sleep(0.1)\n        async with lock_b:  # Different order than operation_2\n            return \"done\"\n\nasync def operation_2():\n    async with lock_b:\n        await asyncio.sleep(0.1)\n        async with lock_a:  # Different order causes deadlock\n            return \"done\"",
    "suggested_fix": "Ensure consistent lock ordering: always acquire locks in the same order across all functions, or use timeout-based lock acquisition: `async with asyncio.timeout(5.0): async with lock_a: async with lock_b:` to prevent indefinite blocking.",
    "file_target": "benchmark/services/post_service.py",
    "generated": true,
    "error": null
  },
  {
    "issue_id": "ARCH-001",
    "issue_name": "Violation of Single Responsibility",
    "category": "Code Architecture & Design Patterns",
    "description": "A class or function handles multiple unrelated responsibilities, making it difficult to maintain, test, and understand. This violates the Single Responsibility Principle from SOLID design principles.",
    "difficulty": "Medium",
    "requirement": null,
    "flawed_snippet": "class UserService:\n    def create_user(self, user_data):\n        # Validates user data\n        if not user_data.email: raise ValueError(\"Email required\")\n        # Sends welcome email\n        send_email(user_data.email, \"Welcome!\")\n        # Saves to database\n        return database.save_user(user_data)",
    "suggested_fix": "Split into separate services: Create `UserValidator`, `EmailService`, and `UserRepository` classes, then compose them in `UserService` that orchestrates the workflow but delegates specific responsibilities.",
    "file_target": "benchmark/services/post_service.py",
    "generated": true,
    "error": ""
  },
  {
    "issue_id": "ARCH-002",
    "issue_name": "Tight Coupling Between Components",
    "category": "Code Architecture & Design Patterns",
    "description": "Components directly depend on concrete implementations rather than abstractions, making the code difficult to test and modify. This violates dependency inversion principles.",
    "difficulty": "Hard",
    "requirement": null,
    "flawed_snippet": "class OrderProcessor:\n    def __init__(self):\n        self.payment = StripePaymentGateway()  # Hard dependency\n        self.inventory = DatabaseInventory()   # Hard dependency\n    \n    def process_order(self, order):\n        self.inventory.reserve_items(order.items)\n        return self.payment.charge(order.total)",
    "suggested_fix": "Use dependency injection with interfaces: `def __init__(self, payment: PaymentGateway, inventory: InventoryService):` and define abstract base classes for PaymentGateway and InventoryService to allow different implementations.",
    "file_target": "benchmark/services/post_service.py",
    "generated": true,
    "error": null
  },
  {
    "issue_id": "ARCH-003",
    "issue_name": "God Object Anti-pattern",
    "category": "Code Architecture & Design Patterns",
    "description": "A single class that knows too much or does too much, becoming overly complex and difficult to maintain. Often indicates poor separation of concerns and violation of multiple design principles.",
    "difficulty": "Hard",
    "requirement": null,
    "flawed_snippet": "class ApplicationManager:\n    def __init__(self):\n        self.users = {}\n        self.orders = {}\n        self.products = {}\n    \n    def create_user(self, data): pass\n    def process_payment(self, order): pass\n    def manage_inventory(self, product): pass\n    def send_notifications(self, user): pass\n    def generate_reports(self): pass",
    "suggested_fix": "Break into focused classes: `UserManager`, `OrderManager`, `ProductManager`, `PaymentProcessor`, `NotificationService`, and `ReportGenerator`. Use a dependency injection container to wire them together.",
    "file_target": "benchmark/services/post_service.py",
    "generated": true,
    "error": null
  },
  {
    "issue_id": "ARCH-004",
    "issue_name": "Missing Abstraction Layer",
    "category": "Code Architecture & Design Patterns",
    "description": "Direct coupling to external services or frameworks without an abstraction layer, making the application dependent on specific implementations and difficult to test or change.",
    "difficulty": "Medium",
    "requirement": null,
    "flawed_snippet": "@app.get(\"/users/{user_id}\")\ndef get_user(user_id: int):\n    # Direct database coupling in controller\n    result = database.execute(\"SELECT * FROM users WHERE id = %s\", (user_id,))\n    if not result:\n        raise HTTPException(404, \"User not found\")\n    return result[0]",
    "suggested_fix": "Create a repository layer: `class UserRepository: def get_by_id(self, user_id: int) -> Optional[User]:` and inject it into the endpoint. This separates data access logic from HTTP handling.",
    "file_target": "benchmark/routers/posts.py",
    "generated": true,
    "error": null
  },
  {
    "issue_id": "ARCH-005",
    "issue_name": "Circular Dependencies",
    "category": "Code Architecture & Design Patterns",
    "description": "Two or more modules import each other, creating circular dependencies that can cause import errors and indicate poor module organization.",
    "difficulty": "Hard",
    "requirement": null,
    "flawed_snippet": "# users.py\nfrom orders import calculate_user_total\n\nclass User:\n    def get_spending(self):\n        return calculate_user_total(self.id)\n\n# orders.py\nfrom users import User\n\ndef calculate_user_total(user_id):\n    user = User.get_by_id(user_id)  # Circular import\n    return sum(order.total for order in user.orders)",
    "suggested_fix": "Refactor to break the cycle: Move shared functionality to a separate module, use dependency injection, or restructure the code so that higher-level modules depend on lower-level ones without reciprocal dependencies.",
    "file_target": "benchmark/services/post_service.py",
    "generated": true,
    "error": ""
  },
  {
    "issue_id": "ARCH-006",
    "issue_name": "Inappropriate Use of Inheritance",
    "category": "Code Architecture & Design Patterns",
    "description": "Using inheritance when composition would be more appropriate, or creating deep inheritance hierarchies that are difficult to understand and maintain.",
    "difficulty": "Medium",
    "requirement": null,
    "flawed_snippet": "class DatabaseUser(User):\n    def save(self): pass\n\nclass CachedDatabaseUser(DatabaseUser):\n    def save(self): pass\n\nclass ValidatedCachedDatabaseUser(CachedDatabaseUser):\n    def save(self): pass",
    "suggested_fix": "Use composition instead: Create `UserRepository`, `CacheService`, and `ValidationService` classes, then compose them: `class UserService: def __init__(self, repo, cache, validator):` to achieve the same functionality with better flexibility.",
    "file_target": "benchmark/services/post_service.py",
    "generated": true,
    "error": null
  },
  {
    "issue_id": "ARCH-007",
    "issue_name": "Missing Design Patterns",
    "category": "Code Architecture & Design Patterns",
    "description": "Not using appropriate design patterns where they would significantly improve code organization, such as Factory patterns for object creation or Strategy patterns for algorithm selection.",
    "difficulty": "Hard",
    "requirement": null,
    "flawed_snippet": "def process_payment(payment_type: str, amount: float):\n    if payment_type == \"credit_card\":\n        # Credit card processing logic\n        return charge_credit_card(amount)\n    elif payment_type == \"paypal\":\n        # PayPal processing logic\n        return charge_paypal(amount)\n    elif payment_type == \"bank_transfer\":\n        # Bank transfer logic\n        return process_bank_transfer(amount)",
    "suggested_fix": "Implement Strategy pattern: Create `PaymentStrategy` interface with implementations like `CreditCardStrategy`, `PayPalStrategy`, etc. Use a factory to create the appropriate strategy: `strategy = PaymentStrategyFactory.create(payment_type); return strategy.process(amount)`.",
    "file_target": "benchmark/services/post_service.py",
    "generated": true,
    "error": ""
  },
  {
    "issue_id": "BIZ-001",
    "issue_name": "Incorrect Discount Calculation",
    "category": "Business Logic & Requirement Mismatches",
    "description": "The code implements a discount calculation but uses wrong constants, logic, or misses conditions specified in business requirements. The implementation appears correct syntactically but produces wrong business outcomes.",
    "difficulty": "Hard",
    "requirement": "Premium users receive a 15% discount on orders over $100, but the total discount cannot exceed $50 per order.",
    "flawed_snippet": "def calculate_price(price: float, is_premium: bool) -> float:\n    if is_premium and price > 100:\n        discount = price * 0.15\n        return price - discount\n    return price",
    "suggested_fix": "The code correctly calculates the 15% discount but fails to implement the $50 cap specified in the business requirements. Add logic to enforce the cap: `discount = min(price * 0.15, 50.0)` before applying it.",
    "file_target": "benchmark/services/post_service.py",
    "generated": true,
    "error": ""
  },
  {
    "issue_id": "BIZ-002",
    "issue_name": "Missing Business Rule Validation",
    "category": "Business Logic & Requirement Mismatches",
    "description": "The code processes data without enforcing critical business constraints, leading to invalid states that violate domain rules even though the code executes successfully.",
    "difficulty": "Medium",
    "requirement": "Orders cannot be placed for out-of-stock items, and inventory must be reserved immediately upon order creation.",
    "flawed_snippet": "@app.post(\"/orders/\")\ndef create_order(order_data: OrderCreate):\n    order = Order(**order_data.dict())\n    order.status = \"confirmed\"\n    return database.save_order(order)",
    "suggested_fix": "Add inventory validation before order creation: `for item in order_data.items: if not inventory.is_available(item.product_id, item.quantity): raise HTTPException(400, \"Item out of stock\"); inventory.reserve(item.product_id, item.quantity)` to enforce business constraints.",
    "file_target": "benchmark/services/post_service.py",
    "generated": true,
    "error": null
  },
  {
    "issue_id": "BIZ-003",
    "issue_name": "Incorrect Status Workflow",
    "category": "Business Logic & Requirement Mismatches",
    "description": "The code allows state transitions that violate the defined business process workflow, potentially leading to invalid business states or operations.",
    "difficulty": "Hard",
    "requirement": "Order status must follow the sequence: pending \u2192 confirmed \u2192 shipped \u2192 delivered. Orders can only be cancelled if they are pending or confirmed.",
    "flawed_snippet": "@app.patch(\"/orders/{order_id}/cancel\")\ndef cancel_order(order_id: int):\n    order = database.get_order(order_id)\n    order.status = \"cancelled\"\n    return database.save_order(order)",
    "suggested_fix": "Add workflow validation: `if order.status not in [\"pending\", \"confirmed\"]: raise HTTPException(400, \"Cannot cancel order in current status\")` before allowing the status change to enforce the business workflow rules.",
    "file_target": "benchmark/services/post_service.py",
    "generated": true,
    "error": null
  },
  {
    "issue_id": "BIZ-004",
    "issue_name": "Wrong Access Control Logic",
    "category": "Business Logic & Requirement Mismatches",
    "description": "The code implements access control but uses incorrect logic that doesn't match the specified business authorization rules, potentially allowing unauthorized access or denying legitimate access.",
    "difficulty": "Medium",
    "requirement": "Users can edit posts they created, plus administrators can edit any post, but only within 24 hours of creation.",
    "flawed_snippet": "@app.put(\"/posts/{post_id}\")\ndef update_post(post_id: int, user: User = Depends(get_current_user)):\n    post = database.get_post(post_id)\n    if post.author_id == user.id or user.is_admin:\n        return database.update_post(post_id, data)\n    raise HTTPException(403, \"Access denied\")",
    "suggested_fix": "Add time constraint validation: `if datetime.now() - post.created_at > timedelta(hours=24): raise HTTPException(403, \"Post can only be edited within 24 hours\")` before the existing authorization check to enforce the business time limit.",
    "file_target": "benchmark/services/post_service.py",
    "generated": true,
    "error": null
  },
  {
    "issue_id": "BIZ-005",
    "issue_name": "Incorrect Fee Calculation",
    "category": "Business Logic & Requirement Mismatches",
    "description": "The code calculates fees or charges using logic that doesn't match the specified business pricing model, resulting in incorrect financial transactions.",
    "difficulty": "Hard",
    "requirement": "Transaction fees are 2.5% for amounts under $1000, 2.0% for amounts $1000-$5000, and 1.5% for amounts over $5000. Minimum fee is $0.50.",
    "flawed_snippet": "def calculate_transaction_fee(amount: float) -> float:\n    if amount < 1000:\n        fee = amount * 0.025\n    elif amount <= 5000:\n        fee = amount * 0.020\n    else:\n        fee = amount * 0.015\n    return fee",
    "suggested_fix": "Add minimum fee enforcement: `return max(fee, 0.50)` after calculating the percentage-based fee to ensure the minimum fee requirement is met as specified in the business rules.",
    "file_target": "benchmark/services/post_service.py",
    "generated": true,
    "error": null
  },
  {
    "issue_id": "BIZ-006",
    "issue_name": "Missing Data Retention Policy",
    "category": "Business Logic & Requirement Mismatches",
    "description": "The code doesn't implement required data lifecycle management, violating business or regulatory requirements for data retention, archival, or deletion.",
    "difficulty": "Medium",
    "requirement": "User account data must be permanently deleted 30 days after account deactivation, and all associated personal information must be anonymized.",
    "flawed_snippet": "@app.delete(\"/users/{user_id}\")\ndef deactivate_user(user_id: int):\n    user = database.get_user(user_id)\n    user.is_active = False\n    user.deactivated_at = datetime.now()\n    return database.save_user(user)",
    "suggested_fix": "Implement data retention logic: Add a background job or trigger that runs daily to check `if user.deactivated_at and datetime.now() - user.deactivated_at > timedelta(days=30): database.permanently_delete_user(user_id); database.anonymize_user_data(user_id)` to comply with data retention requirements.",
    "file_target": "benchmark/services/post_service.py",
    "generated": true,
    "error": null
  },
  {
    "issue_id": "BIZ-007",
    "issue_name": "Incorrect Aggregation Logic",
    "category": "Business Logic & Requirement Mismatches",
    "description": "The code performs data aggregation or reporting calculations that don't align with the specified business metrics or KPI definitions, leading to incorrect business intelligence.",
    "difficulty": "Medium",
    "requirement": "Monthly revenue should include only completed orders (status='delivered') and exclude refunded amounts. Subscription fees should be counted separately from product sales.",
    "flawed_snippet": "def get_monthly_revenue(month: int, year: int) -> dict:\n    orders = database.get_orders_by_month(month, year)\n    total_revenue = sum(order.total for order in orders)\n    return {\"revenue\": total_revenue}",
    "suggested_fix": "Fix aggregation logic: Filter and separate correctly: `completed_orders = [o for o in orders if o.status == 'delivered']; product_revenue = sum(o.total - o.refunded_amount for o in completed_orders if o.type == 'product'); subscription_revenue = sum(o.total for o in completed_orders if o.type == 'subscription')` to match business definitions.",
    "file_target": "benchmark/services/post_service.py",
    "generated": true,
    "error": ""
  },
  {
    "issue_id": "READ-001",
    "issue_name": "Magic Numbers and Strings",
    "category": "Readability & Maintainability",
    "description": "Using literal numbers or strings throughout the code without explanation of their meaning, making the code difficult to understand and maintain.",
    "difficulty": "Easy",
    "requirement": null,
    "flawed_snippet": "@app.post(\"/upload\")\ndef upload_file(file: UploadFile):\n    if len(file.filename) > 255:\n        raise HTTPException(400, \"Filename too long\")\n    if file.size > 10485760:  # What is this number?\n        raise HTTPException(413, \"File too large\")\n    return process_file(file)",
    "suggested_fix": "Define named constants: `MAX_FILENAME_LENGTH = 255; MAX_FILE_SIZE = 10 * 1024 * 1024  # 10MB` and use them in the code: `if len(file.filename) > MAX_FILENAME_LENGTH:` to make the meaning clear.",
    "file_target": "benchmark/config.py",
    "generated": true,
    "error": null
  },
  {
    "issue_id": "READ-002",
    "issue_name": "Poor Variable Naming",
    "category": "Readability & Maintainability",
    "description": "Using unclear, abbreviated, or misleading variable names that don't convey the variable's purpose or content, making code hard to read and understand.",
    "difficulty": "Easy",
    "requirement": null,
    "flawed_snippet": "def calc(u, o, t):\n    r = u * 0.1\n    if o > 100:\n        r += (o - 100) * 0.05\n    return r + t",
    "suggested_fix": "Use descriptive names: `def calculate_total_price(unit_price: float, quantity: int, tax: float) -> float: base_discount = unit_price * 0.1; bulk_discount = (quantity - 100) * 0.05 if quantity > 100 else 0; return base_discount + bulk_discount + tax`",
    "file_target": "benchmark/services/post_service.py",
    "generated": true,
    "error": null
  },
  {
    "issue_id": "READ-003",
    "issue_name": "Excessive Function Length",
    "category": "Readability & Maintainability",
    "description": "Functions that are too long and do too many things, making them difficult to understand, test, and maintain. Long functions often indicate violation of single responsibility principle.",
    "difficulty": "Medium",
    "requirement": null,
    "flawed_snippet": "@app.post(\"/process-order\")\ndef process_order(order_data: dict):\n    # 50+ lines of validation logic\n    if not order_data.get('email'): raise ValueError(\"Email required\")\n    if not validate_email(order_data['email']): raise ValueError(\"Invalid email\")\n    # 30+ lines of inventory checking\n    for item in order_data['items']:\n        if not check_inventory(item): raise ValueError(\"Out of stock\")\n    # 40+ lines of payment processing\n    payment_result = process_payment(order_data['payment'])\n    # 20+ lines of order creation and notification\n    order = create_order(order_data)\n    send_confirmation(order)\n    return order",
    "suggested_fix": "Break into smaller functions: Create `validate_order_data()`, `check_order_inventory()`, `process_order_payment()`, and `finalize_order()` functions. The main function should orchestrate these steps: `validate_order_data(order_data); check_order_inventory(order_data); payment = process_order_payment(order_data); return finalize_order(order_data, payment)`",
    "file_target": "benchmark/routers/posts.py",
    "generated": true,
    "error": ""
  },
  {
    "issue_id": "READ-004",
    "issue_name": "Deep Nesting Levels",
    "category": "Readability & Maintainability",
    "description": "Code with excessive indentation levels due to nested if statements, loops, or try-catch blocks, making it difficult to follow the logic flow.",
    "difficulty": "Medium",
    "requirement": null,
    "flawed_snippet": "def process_users(users):\n    for user in users:\n        if user.is_active:\n            if user.email_verified:\n                if user.subscription:\n                    if user.subscription.is_valid:\n                        if user.preferences:\n                            send_notification(user)\n                        else:\n                            create_default_preferences(user)",
    "suggested_fix": "Use early returns and guard clauses: `for user in users: if not user.is_active: continue; if not user.email_verified: continue; if not user.subscription or not user.subscription.is_valid: continue; if not user.preferences: create_default_preferences(user); else: send_notification(user)`",
    "file_target": "benchmark/services/post_service.py",
    "generated": true,
    "error": null
  },
  {
    "issue_id": "READ-005",
    "issue_name": "Missing Documentation",
    "category": "Readability & Maintainability",
    "description": "Functions, classes, or modules without docstrings or comments explaining their purpose, parameters, return values, or complex logic.",
    "difficulty": "Easy",
    "requirement": null,
    "flawed_snippet": "def calculate_score(data, weights, threshold):\n    total = sum(d * w for d, w in zip(data, weights))\n    normalized = total / sum(weights)\n    return 1.0 if normalized > threshold else normalized / threshold",
    "suggested_fix": "Add comprehensive docstring: `\"\"\"Calculate weighted score with threshold normalization. Args: data: List of numeric values to score; weights: List of weight values for each data point; threshold: Minimum value for full score (1.0). Returns: float: Normalized score between 0.0 and 1.0\"\"\"`",
    "file_target": "benchmark/services/post_service.py",
    "generated": true,
    "error": null
  },
  {
    "issue_id": "READ-006",
    "issue_name": "Inconsistent Code Style",
    "category": "Readability & Maintainability",
    "description": "Mixing different coding styles, naming conventions, or formatting patterns within the same codebase, making it harder to read and maintain.",
    "difficulty": "Easy",
    "requirement": null,
    "flawed_snippet": "class user_manager:  # snake_case class name\n    def GetUser(self, userId):  # PascalCase method, camelCase param\n        user_data=database.fetch_user(userId)  # No spaces around =\n        if user_data is None:\n                return None  # Inconsistent indentation\n        return user_data",
    "suggested_fix": "Follow consistent Python conventions: `class UserManager: def get_user(self, user_id: int) -> Optional[User]: user_data = database.fetch_user(user_id); if user_data is None: return None; return user_data` using PascalCase for classes, snake_case for functions/variables, and consistent spacing.",
    "file_target": "benchmark/services/post_service.py",
    "generated": true,
    "error": ""
  },
  {
    "issue_id": "READ-007",
    "issue_name": "Complex Conditional Expressions",
    "category": "Readability & Maintainability",
    "description": "Using overly complex boolean expressions or nested conditionals that are difficult to understand and evaluate. This often indicates a need for intermediate variables or helper functions.",
    "difficulty": "Medium",
    "requirement": null,
    "flawed_snippet": "@app.get(\"/posts\")\ndef get_posts(user: User = Depends(get_current_user)):\n    if (user.is_admin or (user.is_verified and user.subscription and user.subscription.plan in ['premium', 'enterprise'] and user.created_at < datetime.now() - timedelta(days=30))) and not user.is_banned:\n        return get_all_posts()\n    return get_public_posts()",
    "suggested_fix": "Break complex conditions into readable parts: `is_premium_user = user.subscription and user.subscription.plan in ['premium', 'enterprise']; is_long_time_user = user.created_at < datetime.now() - timedelta(days=30); can_see_all = user.is_admin or (user.is_verified and is_premium_user and is_long_time_user); if can_see_all and not user.is_banned: return get_all_posts()`",
    "file_target": "benchmark/routers/posts.py",
    "generated": true,
    "error": null
  },
  {
    "issue_id": "PY-001",
    "issue_name": "Not Using Context Managers",
    "category": "Python Best Practices & Idioms",
    "description": "Failing to use context managers for resource management, potentially leading to resource leaks when files, connections, or locks are not properly closed or released.",
    "difficulty": "Easy",
    "requirement": null,
    "flawed_snippet": "@app.get(\"/read-config\")\ndef read_config():\n    file = open(\"config.json\", \"r\")\n    data = json.load(file)\n    file.close()  # May not execute if exception occurs\n    return data",
    "suggested_fix": "Use context manager: `with open(\"config.json\", \"r\") as file: data = json.load(file); return data` to ensure the file is properly closed even if an exception occurs.",
    "file_target": "benchmark/main.py",
    "generated": true,
    "error": null
  },
  {
    "issue_id": "PY-002",
    "issue_name": "Inefficient Dictionary Operations",
    "category": "Python Best Practices & Idioms",
    "description": "Using inefficient dictionary access patterns, such as checking key existence separately from accessing values, or not using dictionary methods like get() with defaults.",
    "difficulty": "Easy",
    "requirement": null,
    "flawed_snippet": "def get_user_setting(user_id: int, setting_name: str):\n    settings = get_user_settings(user_id)\n    if setting_name in settings:\n        return settings[setting_name]\n    else:\n        return \"default_value\"",
    "suggested_fix": "Use dict.get() with default: `return settings.get(setting_name, \"default_value\")` for more concise and efficient dictionary access with fallback values.",
    "file_target": "benchmark/services/post_service.py",
    "generated": true,
    "error": ""
  },
  {
    "issue_id": "PY-003",
    "issue_name": "Not Using List Comprehensions",
    "category": "Python Best Practices & Idioms",
    "description": "Using verbose loops with append operations when list comprehensions would be more Pythonic, readable, and often more efficient.",
    "difficulty": "Easy",
    "requirement": null,
    "flawed_snippet": "@app.get(\"/active-users\")\ndef get_active_users():\n    all_users = database.get_all_users()\n    active_users = []\n    for user in all_users:\n        if user.is_active:\n            active_users.append(user.email)\n    return active_users",
    "suggested_fix": "Use list comprehension: `active_users = [user.email for user in database.get_all_users() if user.is_active]` for more concise and Pythonic code.",
    "file_target": "benchmark/routers/posts.py",
    "generated": true,
    "error": null
  },
  {
    "issue_id": "PY-004",
    "issue_name": "Improper Exception Chaining",
    "category": "Python Best Practices & Idioms",
    "description": "Not properly chaining exceptions when wrapping or re-raising them, losing valuable debugging information about the original cause of the error.",
    "difficulty": "Medium",
    "requirement": null,
    "flawed_snippet": "@app.get(\"/data/{file_id}\")\ndef get_data(file_id: str):\n    try:\n        return load_file_data(file_id)\n    except FileNotFoundError:\n        raise HTTPException(404, \"Data not found\")  # Lost original exception",
    "suggested_fix": "Chain exceptions properly: `except FileNotFoundError as e: raise HTTPException(404, \"Data not found\") from e` to preserve the original exception information for debugging while providing a clean API response.",
    "file_target": "benchmark/routers/posts.py",
    "generated": true,
    "error": null
  },
  {
    "issue_id": "PY-005",
    "issue_name": "Not Using Enum for Constants",
    "category": "Python Best Practices & Idioms",
    "description": "Using string literals or magic numbers for status values, types, or other constants instead of using Python's Enum class for better type safety and maintainability.",
    "difficulty": "Medium",
    "requirement": null,
    "flawed_snippet": "@app.post(\"/orders/\")\ndef create_order(order: OrderCreate):\n    new_order = Order(**order.dict())\n    new_order.status = \"pending\"  # Magic string\n    if validate_payment(order.payment):\n        new_order.status = \"confirmed\"  # Another magic string\n    return new_order",
    "suggested_fix": "Use Enum: `from enum import Enum; class OrderStatus(Enum): PENDING = \"pending\"; CONFIRMED = \"confirmed\"; CANCELLED = \"cancelled\"` then use `new_order.status = OrderStatus.PENDING.value` for type-safe constant values.",
    "file_target": "benchmark/services/post_service.py",
    "generated": true,
    "error": null
  },
  {
    "issue_id": "PY-006",
    "issue_name": "Ignoring Pythonic Iteration",
    "category": "Python Best Practices & Idioms",
    "description": "Using index-based loops when more Pythonic iteration methods are available, such as enumerate() for index tracking or zip() for parallel iteration.",
    "difficulty": "Easy",
    "requirement": null,
    "flawed_snippet": "def process_user_scores(users, scores):\n    results = []\n    for i in range(len(users)):\n        user = users[i]\n        score = scores[i]\n        results.append(f\"{user.name}: {score}\")\n    return results",
    "suggested_fix": "Use zip() for parallel iteration: `return [f\"{user.name}: {score}\" for user, score in zip(users, scores)]` which is more readable and handles mismatched list lengths gracefully.",
    "file_target": "benchmark/services/post_service.py",
    "generated": true,
    "error": null
  },
  {
    "issue_id": "PY-007",
    "issue_name": "Not Using Type Hints",
    "category": "Python Best Practices & Idioms",
    "description": "Missing type annotations on function parameters and return values, reducing code clarity and preventing static type checking tools from catching potential errors.",
    "difficulty": "Medium",
    "requirement": null,
    "flawed_snippet": "@app.post(\"/calculate\")\ndef calculate_discount(base_price, discount_percent, user_level):\n    if user_level == \"premium\":\n        discount_percent += 5\n    return base_price * (1 - discount_percent / 100)",
    "suggested_fix": "Add comprehensive type hints: `from typing import Literal; @app.post(\"/calculate\") def calculate_discount(base_price: float, discount_percent: float, user_level: Literal[\"basic\", \"premium\"]) -> float:` to improve code clarity and enable static analysis.",
    "file_target": "benchmark/routers/posts.py",
    "generated": true,
    "error": null
  },
  {
    "issue_id": "TEST-001",
    "issue_name": "Missing Unit Tests",
    "category": "Testing & Reliability",
    "description": "Critical business logic functions without corresponding unit tests, making it difficult to verify correctness and catch regressions during development.",
    "difficulty": "Medium",
    "requirement": null,
    "flawed_snippet": "def calculate_shipping_cost(weight: float, distance: float, express: bool = False) -> float:\n    base_cost = weight * 0.1 + distance * 0.05\n    if express:\n        base_cost *= 1.5\n    return round(base_cost, 2)\n\n# No corresponding test file or test cases",
    "suggested_fix": "Create comprehensive unit tests: `def test_calculate_shipping_cost(): assert calculate_shipping_cost(10, 100, False) == 6.0; assert calculate_shipping_cost(10, 100, True) == 9.0; assert calculate_shipping_cost(0, 0, False) == 0.0` covering normal cases, edge cases, and boundary conditions.",
    "file_target": "tests/test_services.py",
    "generated": true,
    "error": ""
  },
  {
    "issue_id": "TEST-002",
    "issue_name": "Insufficient Error Testing",
    "category": "Testing & Reliability",
    "description": "Tests that only cover successful scenarios without testing error conditions, edge cases, or failure modes that the application should handle gracefully.",
    "difficulty": "Hard",
    "requirement": null,
    "flawed_snippet": "def test_user_creation():\n    user_data = {\"name\": \"John\", \"email\": \"john@example.com\"}\n    result = create_user(user_data)\n    assert result[\"status\"] == \"success\"\n    # Missing tests for: invalid email, duplicate email, missing fields, etc.",
    "suggested_fix": "Add error case tests: `def test_user_creation_invalid_email(): with pytest.raises(ValidationError): create_user({\"name\": \"John\", \"email\": \"invalid\"}); def test_user_creation_duplicate_email(): create_user(valid_data); with pytest.raises(DuplicateError): create_user(valid_data)` to ensure robust error handling.",
    "file_target": "tests/test_services.py",
    "generated": true,
    "error": ""
  },
  {
    "issue_id": "TEST-003",
    "issue_name": "Test Dependencies and Order",
    "category": "Testing & Reliability",
    "description": "Tests that depend on other tests to run first or that fail when run in isolation, indicating poor test isolation and making the test suite unreliable.",
    "difficulty": "Hard",
    "requirement": null,
    "flawed_snippet": "def test_create_user():\n    global created_user_id\n    user = create_user({\"name\": \"Test User\"})\n    created_user_id = user.id\n\ndef test_get_user():\n    # Depends on test_create_user running first\n    user = get_user(created_user_id)\n    assert user.name == \"Test User\"",
    "suggested_fix": "Make tests independent: `@pytest.fixture def sample_user(): return create_user({\"name\": \"Test User\"}); def test_get_user(sample_user): user = get_user(sample_user.id); assert user.name == \"Test User\"` using fixtures to set up required state for each test.",
    "file_target": "tests/test_api.py",
    "generated": true,
    "error": null
  },
  {
    "issue_id": "TEST-004",
    "issue_name": "Mocking External Dependencies",
    "category": "Testing & Reliability",
    "description": "Tests that make real calls to external services, databases, or APIs instead of using mocks, making tests slow, flaky, and dependent on external systems.",
    "difficulty": "Medium",
    "requirement": null,
    "flawed_snippet": "def test_send_welcome_email():\n    user = {\"email\": \"test@example.com\", \"name\": \"Test\"}\n    # This makes a real API call to email service\n    result = send_welcome_email(user)\n    assert result.status_code == 200",
    "suggested_fix": "Use mocks for external calls: `@patch('email_service.send_email') def test_send_welcome_email(mock_send): mock_send.return_value = Mock(status_code=200); result = send_welcome_email(user); mock_send.assert_called_once_with(\"test@example.com\", \"Welcome!\", ANY)` to isolate the unit under test.",
    "file_target": "tests/test_services.py",
    "generated": true,
    "error": null
  },
  {
    "issue_id": "TEST-005",
    "issue_name": "Inadequate Test Coverage",
    "category": "Testing & Reliability",
    "description": "Missing tests for important code paths, especially error handling, edge cases, and complex conditional logic, leading to undetected bugs in production.",
    "difficulty": "Hard",
    "requirement": null,
    "flawed_snippet": "def process_payment(amount: float, payment_method: str) -> dict:\n    if amount <= 0:\n        raise ValueError(\"Invalid amount\")\n    if payment_method == \"credit_card\":\n        return charge_credit_card(amount)\n    elif payment_method == \"paypal\":\n        return charge_paypal(amount)\n    else:\n        return {\"status\": \"unsupported_method\"}\n\n# Tests only cover credit_card path, missing other branches",
    "suggested_fix": "Test all code paths: Add tests for PayPal path, unsupported method path, and edge cases: `def test_process_payment_paypal(); def test_process_payment_unsupported(); def test_process_payment_negative_amount()` to ensure comprehensive coverage of all execution paths.",
    "file_target": "tests/test_services.py",
    "generated": true,
    "error": null
  },
  {
    "issue_id": "TEST-006",
    "issue_name": "Flaky Tests",
    "category": "Testing & Reliability",
    "description": "Tests that sometimes pass and sometimes fail without code changes, often due to timing issues, race conditions, or dependencies on external state.",
    "difficulty": "Hard",
    "requirement": null,
    "flawed_snippet": "@pytest.mark.asyncio\nasync def test_async_operation():\n    task = asyncio.create_task(long_running_operation())\n    await asyncio.sleep(0.1)  # Arbitrary wait time\n    assert task.done()  # May fail if operation takes longer",
    "suggested_fix": "Make tests deterministic: `@pytest.mark.asyncio async def test_async_operation(): result = await long_running_operation(); assert result.status == \"completed\"` or use proper synchronization: `await asyncio.wait_for(task, timeout=5.0)` instead of arbitrary sleeps.",
    "file_target": "tests/test_api.py",
    "generated": true,
    "error": ""
  },
  {
    "issue_id": "TEST-007",
    "issue_name": "Poor Test Data Management",
    "category": "Testing & Reliability",
    "description": "Using hard-coded test data or not properly cleaning up test data, leading to tests that interfere with each other or become difficult to maintain as the schema evolves.",
    "difficulty": "Medium",
    "requirement": null,
    "flawed_snippet": "def test_user_operations():\n    # Hard-coded data that may become invalid\n    user_id = 12345\n    user = get_user(user_id)  # Assumes user exists\n    assert user.name == \"Fixed Test User\"\n    # No cleanup - user remains in system",
    "suggested_fix": "Use proper test data management: `@pytest.fixture def test_user(): user = create_test_user({\"name\": \"Test User\"}); yield user; cleanup_test_user(user.id); def test_user_operations(test_user): assert test_user.name == \"Test User\"` with fixtures that create and clean up test data automatically.",
    "file_target": "tests/test_api.py",
    "generated": true,
    "error": ""
  }
]